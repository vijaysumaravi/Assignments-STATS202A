{
    "collab_server" : "",
    "contents" : "#########################################################\n## Stat 202A - Homework 6\n## Author: Hariharan Shanmugavadivel\n## Date : November 16th, 2017\n## Description: This script implements linear regression\n## and logistic regression and returns their \n## standard errors\n#########################################################\n\n\n##################################\n## Function 1: QR decomposition ##\n##################################\n\n\nmyQR <- function(A){\n  \n  ## Perform QR decomposition on the matrix A\n  ## Input: \n  ## A, an n x m matrix\n  \n  ########################\n  ## FILL IN CODE BELOW ##\n  ########################  \n  \n  n = dim(A)[1]\n  m = dim(A)[2]\n  \n  R = A\n  Q = diag(n)\n  \n  for(k in 1 : (m - 1)){\n    x = matrix(0, n, 1)\n    x[k:n, 1] = R[k:n, k]\n    v = x\n    \n    v[k] = x[k] + sign(x[k,1]) * norm(x, type=\"F\")\n    s = norm(v, \"F\")\n    \n    if(s != 0){\n      u = v / s\n      R = R - 2 * (u %*% (t(u) %*% R))\n      Q = Q - 2 * (u %*% (t(u) %*% Q))\n    }\n  }\n  \n  \n  ## Function should output a list with Q.transpose and R\n  ## Q is an orthogonal n x n matrix\n  ## R is an upper triangular n x m matrix\n  ## Q and R satisfy the equation: A = Q %*% R\n  return(list(\"Q\" = t(Q), \"R\" = R))\n  \n}\n\n###############################################\n## Function 2: Linear regression based on QR ##\n###############################################\n\nmyLM <- function(X, Y){\n  \n  ## Perform the linear regression of Y on X\n  ## Input: \n  ## X is an n x p matrix of explanatory variables\n  ## Y is an n dimensional vector of responses\n  ## Use myQR (or myQRC) inside of this function\n  \n  ########################\n  ## FILL IN CODE BELOW ##\n  ########################  \n  n=nrow(X)\n  p=ncol(X)\n  Z = cbind(rep(1,n),X, Y)\n  R = myQR(Z)$R\n  R1 = R[1:(p+1), 1:(p+1)]\n  Y1 = R[1:(p+1), p+2]\n  \n  beta_ls = solve(R1, Y1)\n  \n  std_error <- calc_std_error_LM(X, Y, beta_ls)\n  \n  return(list(\"coefficients\" = beta_ls, \"standard_error\" = std_error))\n\n  \n}\n\n######################################\n## Function 3: Logistic regression  ##\n######################################\n\n## Expit/sigmoid function\nexpit <- function(x){\n  1 / (1 + exp(-x))\n}\n\nmyLogistic <- function(X, Y){\n  \n  ## Perform the logistic regression of Y on X\n  ## Input: \n  ## X is an n x p matrix of explanatory variables\n  ## Y is an n dimensional vector of binary responses\n  ## Use myLM (or myLMC) inside of this function\n  \n  ########################\n  ## FILL IN CODE BELOW ##\n  ########################\n  \n  n = dim(X)[1]\n  p = dim(X)[2]\n  \n  beta = matrix(rep(0,p), nrow = p)\n  \n  epsilon = 1e-6\n  \n  repeat\n  {\n    X_beta_product = X %*% beta\n    pr = expit(X_beta_product)\n    z = X_beta_product + (Y - pr)/(pr*(1-pr))\n    sqw = sqrt(pr*(1-pr))\n    mw = matrix(sqw, n, p)\n    xw = mw*X\n    yw = sqw*z\n    \n    beta_n = myLM_logistic(xw, yw)\n    error = sum(abs(beta_n - beta))\n    beta = beta_n\n    if (error < epsilon)\n      break\n    \n    \n    \n  }\n  \n  \n  std_error = calc_std_error_logistic(X, beta)\n  ## Function returns the logistic regression solution vector\n  return(list(\"coefficients\" = beta, \"standard_error\" = std_error))\n  \n}\n\n######################################################\n## Function 4: Standard Error Calculation for LinearReg##\n######################################################\n\ncalc_std_error_LM <- function(X, Y, my_coef){\n  \n  # Find the standard error of Linear Regression\n  \n  X_bias = cbind(rep(1,n),X)\n  XtX_inv = solve(t(X_bias) %*% X_bias)\n  \n  RSS =  sum(((X_bias %*% matrix(my_coef)) - Y)^2)\n  sigma_squared = RSS/(n-p-1)\n  \n  std_error = sqrt(diag(sigma_squared * XtX_inv))\n  \n  return(std_error)\n  \n  \n  \n}\n\n\n######################################################\n## Function 5: Standard Error Calculation for Logistic##\n######################################################\n\ncalc_std_error_logistic <- function(X, my_coef){\n  \n  # Find the standard error of Logistic Regression\n  \n  X_beta_product = X %*% my_coef\n  pr = expit(X_beta_product)\n  w = diag(c(pr*(1-pr)))\n  \n  std_error = solve((t(X) %*% w) %*% X)\n  \n  return(sqrt(diag(std_error)))\n  \n  \n}\n\n###############################################\n## Function 6: Linear regression based on QR ##\n###############################################\n\nmyLM_logistic <- function(X, Y){\n  \n  ## Perform the linear regression of Y on X\n  ## Input: \n  ## X is an n x p matrix of explanatory variables\n  ## Y is an n dimensional vector of responses\n  ## Use myQR (or myQRC) inside of this function\n  \n  ########################\n  ## FILL IN CODE BELOW ##\n  ########################  \n  n=nrow(X)\n  p=ncol(X)\n  Z = cbind(X, Y)\n  R = myQR(Z)$R\n  R1 = R[1:(p), 1:(p)]\n  Y1 = R[1:(p), p+1]\n  \n  beta_ls = solve(R1, Y1)\n  \n  \n  \n  ## Function returns the least squares solution vector\n  return(beta_ls)\n  \n}\n\n",
    "created" : 1510891741516.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1240206709",
    "id" : "E30E3B3E",
    "lastKnownWriteTime" : 1510893819,
    "last_content_update" : 1510893819,
    "path" : "D:/UCLA/Fall 2017/STATS202A - Stats Programming/Assignments/Assignment 6/Answers/myPackage/R/myPackage.R",
    "project_path" : "R/myPackage.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}